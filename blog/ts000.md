## TS 是什么 ？

**TS**：是 **TypeScript** 的简称，是一种由微软开发的自由和开源的编程语言。

**TS和JS的关系**

对比于JS，TS是JS的 **超集**，简单的说就是在 JavaScript 的基础上加入了 **类型系统**，让每个参数都有明确的意义，从而带来了更加 **智能** 的提示。

相对于JS而言，TS属于 **强类型** 语言，所以对于项目而言，会使代码更加规范，从而解决了大型项目代码的复杂性，其次，浏览器是不识别TS的，所以在编译的时候，TS文件会先编译为JS文件。

**安装TS**

执行命令：

```bash
npm install -g typescript 
// 或
yarn global add typescript
```

**查看版本**

```bash
tsc -v
```

**编译**

```bash
tsc test.ts
# test.ts => test.js
```

**在线编译**

我们为了方便起见，可以使用线上的编辑器：[TypeScript Playground](https://www.typescriptlang.org/zh/play)

并且你还可以看看生成对应的`ts`转化`ES5`，`ES6`之后的代码，也有相关的例子供你查看



## TS数据类型

这里将TS的数据类型简单的进行下归类：

+ 基本类型：string、number、boolean、symbol、bigint、null、undefined
+ 引用类型：array、 Tuple(元组)、 object(包含Object和{})、function
+ 特殊类型：any、unknow、void、never、Enum(枚举)
+ 其他类型：类型推理、字面量类型、交叉类型

注：案例中有可能用到type和interface，在下面会详细讲解，有比较模糊的可以先看看

### 基本类型

```typescript
//字符串
let str: string = "Domesy"

// 数字
let num: number = 7

//布尔
let bool: boolean = true

//symbol
let sym: symbol = Symbol();

//bigint
let big: bigint = 10n

//null
let nu: null = null

//undefined
let un: undefined = undefined

```

需要注意：

+ null 和 undefined 两个类型一旦赋值上，就不能在赋值给任何其他类型
+ symbol是独一无二的，假设再定义一个 sym1，那么 `sym === sym1` 为 false

### 引用类型

#### Array

两种方式：

- 类型名称 + []
- Array<数据类型>

```typescript
let arr1: number[] = [1, 2, 3]

let arr2: Array<number> = [1, 2, 3]

let arr2: Array<number> = [1, 2, '3'] // error

//要想是数字类型或字符串类型，需要使用 ｜
let arr3: Array<number | string> = [1, 2, '3'] //ok
```

#### Tuple(元组)

Tuple 可以说是 Array 的一种特殊情况,针对上面的 arr3,我们看他的类型可以是string也可以是number，但对每个元素没有作出具体的限制。

那么 Tuple 的作用就是限制元素的类型并且限制个数的数组,同时 Tuple这个概念值存在于TS，在JS上是不存在的
这里存在一个问题：在TS中,是允许对 Tuple 扩增的（也就是允许使用 push方法），但在访问上不允许

```typescript
let t: [number, string] = [1, '2'] // ok
let t1: [number, string] = [1, 3] // error
let t2: [number, string] = [1] // error
let t3: [number, string] = [1, '1', true] // error

let t5: [number, string] = [1, '2'] // ok
t.push(2)
console.log(t) // [1, '2', 2]

let a =  t[0] // ok
let b = t[1] // ok
let c = t[2] // error
```

#### object

`object` 非原始类型，在定义上直接使用 object 是可以的，但你要更改对象的属性就会报错，原因是并没有使对象的内部具体的属性做限制，所以需要使用 **{}** 来定义内部类型

```typescript
let obj1: object = { a: 1, b: 2}
obj1.a = 3 // error

let obj2: { a: number, b: number } = {a: 1, b: 2}
obj2.a = 3 // ok
```
`Object`(大写的O）,代表所有的原始类型或非原始类型都可以进行赋值,除了`null`和`undefined`

```typescript
let obj: Object;
obj = 1; // ok
obj = "a"; // ok
obj = true; // ok
obj = {}; // ok
obj = Symbol() //ok
obj = 10n //ok
obj = null; // error
obj = undefined; // error
```
#### function

#### 定义函数

- 有两种方式，一种为 `function`， 另一种为`箭头函数`
- 在书写的时候，也可以写入返回值的类型，如果写入，则必须要有对应类型的返回值，**但通常情况下是省略**，因为`TS`的类型推断功能够正确推断出返回值类型

```typescript
function setName1(name: string) { //ok
  console.log("hello", name);
}
setName1("Domesy"); // "hello",  "Domesy"

function setName2(name: string):string { //error
  console.log("hello", name);
}
setName2("Domesy");

function setName3(name: string):string { //error
  console.log("hello", name);
  return 1
}
setName3("Domesy");

function setName4(name: string): string { //ok
  console.log("hello", name);
  return name
}
setName4("Domesy"); // "hello",  "Domesy"

//箭头函数与上述同理
const setName5 = (name:string) => console.log("hello", name);
setName5("Domesy") // "hello",  "Domesy"
```
**参数类型**

- 可选参数： 如果函数要配置可有可无的参数时，可以通过 **?** 实现，切可选参数一定要在最后面
- 默认参数：函数内可以自己设定其默认参数，用 **=** 实现
- 剩余参数：仍可以使用扩展运算符 **...**

```typescript
// 可选参数
const setInfo1 = (name: string, age?: number) => console.log(name, age)
setInfo1('Domesy') //"Domesy",  undefined
setInfo1('Domesy', 7) //"Domesy",  7

// 默认参数
const setInfo2 = (name: string, age: number = 11) => console.log(name, age)
setInfo2('Domesy') //"Domesy",  11
setInfo2('Domesy', 7) //"Domesy",  7

// 剩余参数
const allCount = (...numbers: number[]) => console.log(`数字总和为：${numbers.reduce((val, item) => (val += item), 0)}`)
allCount(1, 2, 3) //"数字总和为：6"
```
**函数重载**

**函数重载**：是使用相同名称和不同参数数量或类型创建多个方法的一种能力。 在 TypeScript 中，表现为给同一个函数提供多个函数类型定义。 简单的说：**可以在同一个函数下定义多种类型值，最后汇总到一块**

```typescript
let obj: any = {};
function setInfo(val: string): void;
function setInfo(val: number): void;
function setInfo(val: boolean): void;
function setInfo(val: string | number | boolean): void {
  if (typeof val === "string") {
    obj.name = val;
  } else {
    obj.age = val;
  }
}
setInfo("Domesy");
setInfo(7);
setInfo(true);
console.log(obj); // { name: 'Domesy', age: 7 }
```
